/**********************************************************************
  gcc -O2 -I secp256k1/src/ -I secp256k1/ pollard-kangaroo.c -lgmp
 **********************************************************************/

#include "libsecp256k1-config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/time.h>
//#include <unistd.h>
#include <math.h>

#include "include/secp256k1.h"
#include "secp256k1.c"

/////////////////////////////////////////////////
// user settings

// 8..120
int pow2bits = 42;


/////////////////////////////////////////////////
// server settings

#define ALGO_CALC 0

// 0: A + A -> A,  xA ready ; 0.291Mk/s; the fastest
// 1: J + A -> J,  xJ->xA   ; 0.274Mk/s; secp256k1_gej_add_ge_var()
// 2: J + A -> J,  xJ->xA   ; 0.267Mk/s; secp256k1_gej_add_ge()
// 3: 0*P0+k*G->J, xJ->xA   ; 0.091Mk/s; secp256k1_ecmult()
// 4: k*G->J, J+J->J, xJ->xA; 0.031Mk/s; secp256k1_ecmult_gen() + secp256k1_gej_add_var()


unsigned char version[4+1] = "0.2";

int FLAG_DEBUG = 0;

unsigned char seed16[16+1] = {0};
//unsigned char seed16[16+1] = "1234567890ABCDEF";

// max elements in hashtable
uint64_t maxDP = 1<<10; // 2^10=1024

#define DIV_BYTE  1000
#define DIV_iBYTE 1024
#define DIV_B (DIV_BYTE)

/////////////////////////////////////////////////
// know pubkeys of puzzle
// bitcointalk.org/index.php?topic=5166284.0

size_t LEN_PUBK = 33; /*   COMPRESSED PUBKEY */
//size_t LEN_PUBK = 65; /* UNCOMPRESSED PUBKEY */

unsigned char default_pubkeys[256][33] = {
{  }, /* 0 */

{ 0x02,0x79,0xbe,0x66,0x7e,0xf9,0xdc,0xbb,0xac,0x55,0xa0,0x62,0x95,0xce,0x87,0x0b,0x07,0x02,0x9b,0xfc,0xdb,0x2d,0xce,0x28,0xd9,0x59,0xf2,0x81,0x5b,0x16,0xf8,0x17,0x98 }, /*  1, 0x01 */
{ 0x02,0xf9,0x30,0x8a,0x01,0x92,0x58,0xc3,0x10,0x49,0x34,0x4f,0x85,0xf8,0x9d,0x52,0x29,0xb5,0x31,0xc8,0x45,0x83,0x6f,0x99,0xb0,0x86,0x01,0xf1,0x13,0xbc,0xe0,0x36,0xf9 }, /*  2, 0x03 */
{ 0x02,0x5c,0xbd,0xf0,0x64,0x6e,0x5d,0xb4,0xea,0xa3,0x98,0xf3,0x65,0xf2,0xea,0x7a,0x0e,0x3d,0x41,0x9b,0x7e,0x03,0x30,0xe3,0x9c,0xe9,0x2b,0xdd,0xed,0xca,0xc4,0xf9,0xbc }, /*  3, 0x07 */
{ 0x02,0x2f,0x01,0xe5,0xe1,0x5c,0xca,0x35,0x1d,0xaf,0xf3,0x84,0x3f,0xb7,0x0f,0x3c,0x2f,0x0a,0x1b,0xdd,0x05,0xe5,0xaf,0x88,0x8a,0x67,0x78,0x4e,0xf3,0xe1,0x0a,0x2a,0x01 }, /*  4, 0x08 */
{ 0x02,0x35,0x2b,0xbf,0x4a,0x4c,0xdd,0x12,0x56,0x4f,0x93,0xfa,0x33,0x2c,0xe3,0x33,0x30,0x1d,0x9a,0xd4,0x02,0x71,0xf8,0x10,0x71,0x81,0x34,0x0a,0xef,0x25,0xbe,0x59,0xd5 }, /*  5, 0x15 */
{ 0x03,0xf2,0xda,0xc9,0x91,0xcc,0x4c,0xe4,0xb9,0xea,0x44,0x88,0x7e,0x5c,0x7c,0x0b,0xce,0x58,0xc8,0x00,0x74,0xab,0x9d,0x4d,0xba,0xeb,0x28,0x53,0x1b,0x77,0x39,0xf5,0x30 }, /*  6, 0x31 */
{ 0x02,0x96,0x51,0x6a,0x8f,0x65,0x77,0x42,0x75,0x27,0x8d,0x0d,0x74,0x20,0xa8,0x8d,0xf0,0xac,0x44,0xbd,0x64,0xc7,0xba,0xe0,0x7c,0x3f,0xe3,0x97,0xc5,0xb3,0x30,0x0b,0x23 }, /*  7, 0x4C */
{ 0x03,0x08,0xbc,0x89,0xc2,0xf9,0x19,0xed,0x15,0x88,0x85,0xc3,0x56,0x00,0x84,0x4d,0x49,0x89,0x09,0x05,0xc7,0x9b,0x35,0x73,0x22,0x60,0x9c,0x45,0x70,0x6c,0xe6,0xb5,0x14 }, /*  8, 0xE0 */
{ 0x02,0x43,0x60,0x1d,0x61,0xc8,0x36,0x38,0x74,0x85,0xe9,0x51,0x4a,0xb5,0xc8,0x92,0x4d,0xd2,0xcf,0xd4,0x66,0xaf,0x34,0xac,0x95,0x00,0x27,0x27,0xe1,0x65,0x9d,0x60,0xf7 }, /*  9, 0x01D3 */
{ 0x03,0xa7,0xa4,0xc3,0x02,0x91,0xac,0x1d,0xb2,0x4b,0x4a,0xb0,0x0c,0x44,0x2a,0xa8,0x32,0xf7,0x79,0x4b,0x5a,0x09,0x59,0xbe,0xc6,0xe8,0xd7,0xfe,0xe8,0x02,0x28,0x9d,0xcd }, /* 10, 0x0202 */
{ 0x03,0x8b,0x05,0xb0,0x60,0x3a,0xbd,0x75,0xb0,0xc5,0x74,0x89,0xe4,0x51,0xf8,0x11,0xe1,0xaf,0xe5,0x4a,0x87,0x15,0x04,0x5c,0xdf,0x48,0x88,0x33,0x3f,0x3e,0xbc,0x6e,0x8b }, /* 11, 0x0483 */
{ 0x03,0x8b,0x00,0xfc,0xbf,0xc1,0xa2,0x03,0xf4,0x4b,0xf1,0x23,0xfc,0x7f,0x4c,0x91,0xc1,0x0a,0x85,0xc8,0xea,0xe9,0x18,0x7f,0x9d,0x22,0x24,0x2b,0x46,0x00,0xce,0x78,0x1c }, /* 12, 0x0A7B */
{ 0x03,0xaa,0xda,0xaa,0xb1,0xdb,0x8d,0x5d,0x45,0x0b,0x51,0x17,0x89,0xc3,0x7e,0x7c,0xfe,0xb0,0xeb,0x8b,0x3e,0x61,0xa5,0x7a,0x34,0x16,0x6c,0x5e,0xdc,0x9a,0x4b,0x86,0x9d }, /* 13, 0x1460 */
{ 0x03,0xb4,0xf1,0xde,0x58,0xb8,0xb4,0x1a,0xfe,0x9f,0xd4,0xe5,0xff,0xbd,0xaf,0xae,0xab,0x86,0xc5,0xdb,0x47,0x69,0xc1,0x5d,0x6e,0x60,0x11,0xae,0x73,0x51,0xe5,0x47,0x59 }, /* 14, 0x2930 */
{ 0x02,0xfe,0xa5,0x8f,0xfc,0xf4,0x95,0x66,0xf6,0xe9,0xe9,0x35,0x0c,0xf5,0xbc,0xa2,0x86,0x13,0x12,0xf4,0x22,0x96,0x6e,0x8d,0xb1,0x60,0x94,0xbe,0xb1,0x4d,0xc3,0xdf,0x2c }, /* 15, 0x68F3 */
{ 0x02,0x9d,0x8c,0x5d,0x35,0x23,0x1d,0x75,0xeb,0x87,0xfd,0x2c,0x5f,0x05,0xf6,0x52,0x81,0xed,0x95,0x73,0xdc,0x41,0x85,0x32,0x88,0xc6,0x2e,0xe9,0x4e,0xb2,0x59,0x0b,0x7a }, /* 16, 0xC936 */
{ 0x03,0x3f,0x68,0x8b,0xae,0x83,0x21,0xb8,0xe0,0x2b,0x7e,0x6c,0x0a,0x55,0xc2,0x51,0x5f,0xb2,0x5a,0xb9,0x7d,0x85,0xfd,0xa8,0x42,0x44,0x9f,0x7b,0xfa,0x04,0xe1,0x28,0xc3 }, /* 17, 0x01764F */
{ 0x02,0x0c,0xe4,0xa3,0x29,0x1b,0x19,0xd2,0xe1,0xa7,0xbf,0x73,0xee,0x87,0xd3,0x0a,0x6b,0xdb,0xc7,0x2b,0x20,0x77,0x1e,0x7d,0xff,0xf4,0x0d,0x0d,0xb7,0x55,0xcd,0x4a,0xf1 }, /* 18, 0x03080D */
{ 0x03,0x85,0x66,0x3c,0x8b,0x2f,0x90,0x65,0x9e,0x1c,0xca,0xb2,0x01,0x69,0x4f,0x4f,0x8e,0xc2,0x4b,0x37,0x49,0xcf,0xe5,0x03,0x0c,0x7c,0x36,0x46,0xa7,0x09,0x40,0x8e,0x19 }, /* 19, 0x05749F */
{ 0x03,0x3c,0x4a,0x45,0xcb,0xd6,0x43,0xff,0x97,0xd7,0x7f,0x41,0xea,0x37,0xe8,0x43,0x64,0x8d,0x50,0xfd,0x89,0x4b,0x86,0x4b,0x0d,0x52,0xfe,0xbc,0x62,0xf6,0x45,0x4f,0x7c }, /* 20, 0x0D2C55 */
{ 0x03,0x1a,0x74,0x6c,0x78,0xf7,0x27,0x54,0xe0,0xbe,0x04,0x61,0x86,0xdf,0x8a,0x20,0xcd,0xce,0x5c,0x79,0xb2,0xed,0xa7,0x60,0x13,0xc6,0x47,0xaf,0x08,0xd3,0x06,0xe4,0x9e }, /* 21, 0x1BA534 */
{ 0x02,0x3e,0xd9,0x6b,0x52,0x4d,0xb5,0xff,0x4f,0xe0,0x07,0xce,0x73,0x03,0x66,0x05,0x2b,0x7c,0x51,0x1d,0xc5,0x66,0x22,0x7d,0x92,0x90,0x70,0xb9,0xce,0x91,0x7a,0xbb,0x43 }, /* 22, 0x2DE40F */
{ 0x03,0xf8,0x27,0x10,0x36,0x1b,0x8b,0x81,0xbd,0xed,0xb1,0x69,0x94,0xf3,0x0c,0x80,0xdb,0x52,0x24,0x50,0xa9,0x3e,0x8e,0x87,0xee,0xb0,0x7f,0x79,0x03,0xcf,0x28,0xd0,0x4b }, /* 23, 0x556E52 */
{ 0x03,0x6e,0xa8,0x39,0xd2,0x28,0x47,0xee,0x1d,0xce,0x3b,0xfc,0x5b,0x11,0xf6,0xcf,0x78,0x5b,0x06,0x82,0xdb,0x58,0xc3,0x5b,0x63,0xd1,0x34,0x2e,0xb2,0x21,0xc3,0x49,0x0c }, /* 24, 0xDC2A04 */
{ 0x03,0x05,0x7f,0xbe,0xa3,0xa2,0x62,0x33,0x82,0x62,0x8d,0xde,0x55,0x6b,0x2a,0x06,0x98,0xe3,0x24,0x28,0xd3,0xcd,0x22,0x5f,0x3b,0xd0,0x34,0xdc,0xa8,0x2d,0xd7,0x45,0x5a }, /* 25, 0x01FA5EE5 */
{ 0x02,0x4e,0x4f,0x50,0xa2,0xa3,0xec,0xcd,0xb3,0x68,0x98,0x8a,0xe3,0x7c,0xd4,0xb6,0x11,0x69,0x7b,0x26,0xb2,0x96,0x96,0xe4,0x2e,0x06,0xd7,0x13,0x68,0xb4,0xf3,0x84,0x0f }, /* 26, 0x0340326E */
{ 0x03,0x1a,0x86,0x4b,0xae,0x39,0x22,0xf3,0x51,0xf1,0xb5,0x7c,0xfd,0xd8,0x27,0xc2,0x5b,0x7e,0x09,0x3c,0xb9,0xc8,0x8a,0x72,0xc1,0xcd,0x89,0x3d,0x9f,0x90,0xf4,0x4e,0xce }, /* 27, 0x06AC3875 */
{ 0x03,0xe9,0xe6,0x61,0x83,0x8a,0x96,0xa6,0x53,0x31,0x63,0x7e,0x2a,0x3e,0x94,0x8d,0xc0,0x75,0x6e,0x50,0x09,0xe7,0xcb,0x5c,0x36,0x66,0x4d,0x9b,0x72,0xdd,0x18,0xc0,0xa7 }, /* 28, 0x0D916CE8 */
{ 0x02,0x6c,0xaa,0xd6,0x34,0x38,0x2d,0x34,0x69,0x1e,0x3b,0xef,0x43,0xed,0x4a,0x12,0x4d,0x89,0x09,0xa8,0xa3,0x36,0x2f,0x91,0xf1,0xd2,0x0a,0xba,0xaf,0x7e,0x91,0x7b,0x36 }, /* 29, 0x17E2551E */
{ 0x03,0x0d,0x28,0x2c,0xf2,0xff,0x53,0x6d,0x2c,0x42,0xf1,0x05,0xd0,0xb8,0x58,0x88,0x21,0xa9,0x15,0xdc,0x3f,0x9a,0x05,0xbd,0x98,0xbb,0x23,0xaf,0x67,0xa2,0xe9,0x2a,0x5b }, /* 30, 0x3D94CD64 */
{ 0x03,0x87,0xdc,0x70,0xdb,0x18,0x06,0xcd,0x9a,0x9a,0x76,0x63,0x74,0x12,0xec,0x11,0xdd,0x99,0x8b,0xe6,0x66,0x58,0x48,0x49,0xb3,0x18,0x5f,0x7f,0x93,0x13,0xc8,0xfd,0x28 }, /* 31, 0x7D4FE747 */
{ 0x02,0x09,0xc5,0x82,0x40,0xe5,0x0e,0x3b,0xa3,0xf8,0x33,0xc8,0x26,0x55,0xe8,0x72,0x5c,0x03,0x7a,0x22,0x94,0xe1,0x4c,0xf5,0xd7,0x3a,0x5d,0xf8,0xd5,0x61,0x59,0xde,0x69 }, /* 32, 0xB862A62E */
{ 0x03,0xa3,0x55,0xaa,0x5e,0x2e,0x09,0xdd,0x44,0xbb,0x46,0xa4,0x72,0x2e,0x93,0x36,0xe9,0xe3,0xee,0x4e,0xe4,0xe7,0xb7,0xa0,0xcf,0x57,0x85,0xb2,0x83,0xbf,0x2a,0xb5,0x79 }, /* 33, 0x01A96CA8D8 */
{ 0x03,0x3c,0xdd,0x9d,0x6d,0x97,0xcb,0xfe,0x7c,0x26,0xf9,0x02,0xfa,0xf6,0xa4,0x35,0x78,0x0f,0xe6,0x52,0xe1,0x59,0xec,0x95,0x36,0x50,0xec,0x7b,0x10,0x04,0x08,0x27,0x90 }, /* 34, 0x034A65911D */
{ 0x02,0xf6,0xa8,0x14,0x8a,0x62,0x32,0x0e,0x14,0x9c,0xb1,0x5c,0x54,0x4f,0xe8,0xa2,0x5a,0xb4,0x83,0xa0,0x09,0x5d,0x22,0x80,0xd0,0x3b,0x8a,0x00,0xa7,0xfe,0xad,0xa1,0x3d }, /* 35, 0x04AED21170 */
{ 0x02,0xb3,0xe7,0x72,0x21,0x66,0x95,0x84,0x5f,0xa9,0xdd,0xa4,0x19,0xfb,0x5d,0xac,0xa2,0x81,0x54,0xd8,0xaa,0x59,0xea,0x30,0x2f,0x05,0xe9,0x16,0x63,0x5e,0x47,0xb9,0xf6 }, /* 36, 0x09DE820A7C */
{ 0x02,0x7d,0x2c,0x03,0xc3,0xef,0x0a,0xec,0x70,0xf2,0xc7,0xe1,0xe7,0x54,0x54,0xa5,0xdf,0xdd,0x0e,0x1a,0xde,0xa6,0x70,0xc1,0xb3,0xa4,0x64,0x3c,0x48,0xad,0x0f,0x12,0x55 }, /* 37, 0x1757756A93 */
{ 0x03,0xc0,0x60,0xe1,0xe3,0x77,0x1c,0xbe,0xcc,0xb3,0x8e,0x11,0x9c,0x24,0x14,0x70,0x2f,0x3f,0x51,0x81,0xa8,0x96,0x52,0x53,0x88,0x51,0xd2,0xe3,0x88,0x6b,0xdd,0x70,0xc6 }, /* 38, 0x22382FACD0 */
{ 0x02,0x2d,0x77,0xcd,0x14,0x67,0x01,0x9a,0x6b,0xf2,0x8f,0x73,0x75,0xd0,0x94,0x9c,0xe3,0x0e,0x6b,0x58,0x15,0xc2,0x75,0x8b,0x98,0xa7,0x4c,0x27,0x00,0xbc,0x00,0x65,0x43 }, /* 39, 0x4B5F8303E9 */
{ 0x03,0xa2,0xef,0xa4,0x02,0xfd,0x52,0x68,0x40,0x0c,0x77,0xc2,0x0e,0x57,0x4b,0xa8,0x64,0x09,0xed,0xed,0xee,0x7c,0x40,0x20,0xe4,0xb9,0xf0,0xed,0xbe,0xe5,0x3d,0xe0,0xd4 }, /* 40, 0xE9AE4933D6 */
{ 0x03,0xb3,0x57,0xe6,0x84,0x37,0xda,0x27,0x3d,0xcf,0x99,0x5a,0x47,0x4a,0x52,0x44,0x39,0xfa,0xad,0x86,0xfc,0x9e,0xff,0xc3,0x00,0x18,0x3f,0x71,0x4b,0x09,0x03,0x46,0x8b }, /* 41, 0x0153869ACC5B */
{ 0x03,0xee,0xc8,0x83,0x85,0xbe,0x9d,0xa8,0x03,0xa0,0xd6,0x57,0x97,0x98,0xd9,0x77,0xa5,0xd0,0xc7,0xf8,0x09,0x17,0xda,0xb4,0x9c,0xb7,0x3c,0x9e,0x39,0x27,0x14,0x2c,0xb6 }, /* 42, 0x02A221C58D8F */
{ 0x02,0xa6,0x31,0xf9,0xba,0x0f,0x28,0x51,0x16,0x14,0x90,0x4d,0xf8,0x0d,0x7f,0x97,0xa4,0xf4,0x3f,0x02,0x24,0x9c,0x89,0x09,0xda,0xc9,0x22,0x76,0xcc,0xf0,0xbc,0xda,0xed }, /* 43, 0x06BD3B27C591 */
{ 0x02,0x5e,0x46,0x6e,0x97,0xed,0x0e,0x79,0x10,0xd3,0xd9,0x0c,0xeb,0x03,0x32,0xdf,0x48,0xdd,0xf6,0x7d,0x45,0x6b,0x9e,0x73,0x03,0xb5,0x0a,0x3d,0x89,0xde,0x35,0x73,0x36 }, /* 44, 0x0E02B35A358F */
{ 0x02,0x6e,0xca,0xbd,0x2d,0x22,0xfd,0xb7,0x37,0xbe,0x21,0x97,0x5c,0xe9,0xa6,0x94,0xe1,0x08,0xeb,0x94,0xf3,0x64,0x9c,0x58,0x6c,0xc7,0x46,0x1c,0x8a,0xbf,0x5d,0xa7,0x1a }, /* 45, 0x122FCA143C05 */
{ 0x03,0xfd,0x54,0x87,0x72,0x2d,0x25,0x76,0xcb,0x6d,0x70,0x81,0x42,0x6b,0x66,0xa3,0xe2,0x98,0x6c,0x1c,0xe8,0x35,0x8d,0x47,0x90,0x63,0xfb,0x5f,0x2b,0xb6,0xdd,0x58,0x49 }, /* 46, 0x2EC18388D544 */
{ 0x02,0x3a,0x12,0xbd,0x3c,0xaf,0x0b,0x0f,0x77,0xbf,0x4e,0xea,0x8e,0x7a,0x40,0xdb,0xe2,0x79,0x32,0xbf,0x80,0xb1,0x9a,0xc7,0x2f,0x5f,0x5a,0x64,0x92,0x5a,0x59,0x41,0x96 }, /* 47, 0x6CD610B53CBA */
{ 0x02,0x91,0xbe,0xe5,0xcf,0x4b,0x14,0xc2,0x91,0xc6,0x50,0x73,0x2f,0xaa,0x16,0x60,0x40,0xe4,0xc1,0x8a,0x14,0x73,0x1f,0x9a,0x93,0x0c,0x1e,0x87,0xd3,0xec,0x12,0xde,0xbb }, /* 48, 0xADE6D7CE3B9B */
{ 0x02,0x59,0x1d,0x68,0x2c,0x3d,0xa4,0xa2,0xa6,0x98,0x63,0x3b,0xf5,0x75,0x17,0x38,0xb6,0x7c,0x34,0x32,0x85,0xeb,0xdc,0x34,0x92,0x64,0x5c,0xb4,0x46,0x58,0x91,0x14,0x84 }, /* 49, 0x0174176B015F4D */
{ 0x03,0xf4,0x6f,0x41,0x02,0x7b,0xbf,0x44,0xfa,0xfd,0x6b,0x05,0x90,0x91,0xb9,0x00,0xda,0xd4,0x1e,0x68,0x45,0xb2,0x24,0x1d,0xc3,0x25,0x4c,0x7c,0xdd,0x3c,0x5a,0x16,0xc6 }, /* 50, 0x022BD43C2E9354 */
{ 0x02,0x8c,0x6c,0x67,0xbe,0xf9,0xe9,0xee,0xbe,0x6a,0x51,0x32,0x72,0xe5,0x0c,0x23,0x0f,0x0f,0x91,0xed,0x56,0x0c,0x37,0xbc,0x9b,0x03,0x32,0x41,0xff,0x6c,0x3b,0xe7,0x8f }, /* 51, 0x075070A1A009D4 */
{ 0x03,0x74,0xc3,0x3b,0xd5,0x48,0xef,0x02,0x66,0x7d,0x61,0x34,0x18,0x92,0x13,0x4f,0xcf,0x21,0x66,0x40,0xbc,0x22,0x01,0xae,0x61,0x92,0x8c,0xd0,0x87,0x4f,0x63,0x14,0xa7 }, /* 52, 0x0EFAE164CB9E3C */
{ 0x02,0x0f,0xAA,0xf5,0xf3,0xaf,0xe5,0x83,0x00,0xa3,0x35,0x87,0x4c,0x80,0x68,0x1c,0xf6,0x69,0x33,0xe2,0xa7,0xae,0xb2,0x83,0x87,0xc0,0xd2,0x8b,0xb0,0x48,0xbc,0x63,0x49 }, /* 53, 0x180788E47E326C */
{ 0x03,0x4a,0xf4,0xb8,0x1f,0x8c,0x45,0x0c,0x2c,0x87,0x0c,0xe1,0xdf,0x18,0x4a,0xff,0x12,0x97,0xe5,0xfc,0xd5,0x49,0x44,0xd9,0x8d,0x81,0xe1,0xa5,0x45,0xff,0xb2,0x25,0x96 }, /* 54, 0x236FB6D5AD1F43 */
{ 0x03,0x85,0xa3,0x0d,0x84,0x13,0xaf,0x4f,0x8f,0x9e,0x63,0x12,0x40,0x0f,0x2d,0x19,0x4f,0xe1,0x4f,0x02,0xe7,0x19,0xb2,0x4c,0x3f,0x83,0xbf,0x1f,0xd2,0x33,0xa8,0xf9,0x63 }, /* 55, 0x6ABE1F9B67E114 */
{ 0x03,0x3f,0x2d,0xb2,0x07,0x4e,0x32,0x17,0xb3,0xe5,0xee,0x30,0x53,0x01,0xee,0xeb,0xb1,0x16,0x0c,0x4f,0xa1,0xe9,0x93,0xee,0x28,0x01,0x12,0xf6,0x34,0x86,0x37,0x99,0x9a }, /* 56, 0x9D18B63AC4FFDF */
{ 0x02,0xa5,0x21,0xa0,0x7e,0x98,0xf7,0x8b,0x03,0xfc,0x1e,0x03,0x9b,0xc3,0xa5,0x14,0x08,0xcd,0x73,0x11,0x9b,0x5e,0xb1,0x16,0xe5,0x83,0xfe,0x57,0xdc,0x8d,0xb0,0x7a,0xea }, /* 57, 0x01EB25C90795D61C */
{ 0x03,0x11,0x56,0x94,0x42,0xe8,0x70,0x32,0x6c,0xee,0xc0,0xde,0x24,0xeb,0x54,0x78,0xc1,0x9e,0x14,0x6e,0xcd,0x9d,0x15,0xe4,0x66,0x64,0x40,0xf2,0xf6,0x38,0x87,0x5f,0x42 }, /* 58, 0x02C675B852189A21 */
{ 0x02,0x41,0x26,0x7d,0x2d,0x7e,0xe1,0xa8,0xe7,0x6f,0x8d,0x15,0x46,0xd0,0xd3,0x0a,0xef,0xb2,0x89,0x2d,0x23,0x1c,0xee,0x0d,0xde,0x77,0x76,0xda,0xf9,0xf8,0x02,0x14,0x85 }, /* 59, 0x07496CBB87CAB44F */
{ 0x03,0x48,0xe8,0x43,0xdc,0x5b,0x1b,0xd2,0x46,0xe6,0x30,0x9b,0x49,0x24,0xb8,0x15,0x43,0xd0,0x2b,0x16,0xc8,0x08,0x3d,0xf9,0x73,0xa8,0x9c,0xe2,0xc7,0xeb,0x89,0xa1,0x0d }, /* 60, 0x0FC07A1825367BBE */
{ 0x02,0x49,0xa4,0x38,0x60,0xd1,0x15,0x14,0x3c,0x35,0xc0,0x94,0x54,0x86,0x3d,0x6f,0x82,0xa9,0x5e,0x47,0xc1,0x16,0x2f,0xb9,0xb2,0xeb,0xe0,0x18,0x6e,0xb2,0x6f,0x45,0x3f }, /* 61, 0x13C96A3742F64906 */
{ 0x03,0x23,0x1a,0x67,0xe4,0x24,0xca,0xf7,0xd0,0x1a,0x00,0xd5,0xcd,0x49,0xb0,0x46,0x49,0x42,0x25,0x5b,0x8e,0x48,0x76,0x6f,0x96,0x60,0x2b,0xdf,0xa4,0xea,0x14,0xfe,0xa8 }, /* 62, 0x363D541EB611ABEE */
{ 0x03,0x65,0xec,0x29,0x94,0xb8,0xcc,0x0a,0x20,0xd4,0x0d,0xd6,0x9e,0xdf,0xe5,0x5c,0xa3,0x2a,0x54,0xbc,0xbb,0xaa,0x6b,0x0d,0xdc,0xff,0x36,0x04,0x93,0x01,0xa5,0x45,0x79 }, /* 63, 0x7CCE5EFDACCF6808 */
{  }, /* 64, 0x */
{ 0x02,0x30,0x21,0x0c,0x23,0xb1,0xa0,0x47,0xbc,0x9b,0xdb,0xb1,0x34,0x48,0xe6,0x7d,0xed,0xdc,0x10,0x89,0x46,0xde,0x6d,0xe6,0x39,0xbc,0xc7,0x5d,0x47,0xc0,0x21,0x6b,0x1b }, /* 65, 0x01A838B13505B26867 */
{  }, /* 66, 0x */
{  }, /* 67, 0x */
{  }, /* 68, 0x */
{  }, /* 69, 0x */
{ 0x02,0x90,0xe6,0x90,0x0a,0x58,0xd3,0x33,0x93,0xbc,0x10,0x97,0xb5,0xae,0xd3,0x1f,0x2e,0x4e,0x7c,0xbd,0x3e,0x54,0x66,0xaf,0x95,0x86,0x65,0xbc,0x01,0x21,0x24,0x84,0x83 }, /* 70, 0x349B84B6431A6C4EF1 */
{  }, /* 71, 0x */
{  }, /* 72, 0x */
{  }, /* 73, 0x */
{  }, /* 74, 0x */
{ 0x03,0x72,0x6b,0x57,0x4f,0x19,0x3e,0x37,0x46,0x86,0xd8,0xe1,0x2b,0xc6,0xe4,0x14,0x2a,0xde,0xb0,0x67,0x70,0xe0,0xa2,0x85,0x6f,0x5e,0x4a,0xd8,0x9f,0x66,0x04,0x47,0x55 }, /* 75, 0x04C5CE114686A1336E07 */
{  }, /* 76, 0x */
{  }, /* 77, 0x */
{  }, /* 78, 0x */
{  }, /* 79, 0x */
{ 0x03,0x7e,0x12,0x38,0xf7,0xb1,0xce,0x75,0x7d,0xf9,0x4f,0xaa,0x9a,0x2e,0xb2,0x61,0xbf,0x0a,0xeb,0x9f,0x84,0xdb,0xf8,0x12,0x12,0x10,0x4e,0x78,0x93,0x1c,0x2a,0x19,0xdc }, /* 80, 0xEA1A5C66DCC11B5AD180 */
{  }, /* 81, 0x */
{  }, /* 82, 0x */
{  }, /* 83, 0x */
{  }, /* 84, 0x */
{ 0x03,0x29,0xc4,0x57,0x4a,0x4f,0xd8,0xc8,0x10,0xb7,0xe4,0x2a,0x4b,0x39,0x88,0x82,0xb3,0x81,0xbc,0xd8,0x5e,0x40,0xc6,0x88,0x37,0x12,0x91,0x2d,0x16,0x7c,0x83,0xe7,0x3a }, /* 85, 0x11720C4F018D51B8CEBBA8 */
{  }, /* 86, 0x */
{  }, /* 87, 0x */
{  }, /* 88, 0x */
{  }, /* 89, 0x */
{ 0x03,0x5c,0x38,0xbd,0x9a,0xe4,0xb1,0x0e,0x8a,0x25,0x08,0x57,0x00,0x6f,0x3c,0xfd,0x98,0xab,0x15,0xa6,0x19,0x6d,0x9f,0x4d,0xfd,0x25,0xbc,0x7e,0xcc,0x77,0xd7,0x88,0xd5 }, /* 90, 0x02CE00BB2136A445C71E85BF */
{  }, /* 91, 0x */
{  }, /* 92, 0x */
{  }, /* 93, 0x */
{  }, /* 94, 0x */
{ 0x02,0x96,0x7a,0x59,0x05,0xd6,0xf3,0xb4,0x20,0x95,0x9a,0x02,0x78,0x9f,0x96,0xab,0x4c,0x32,0x23,0xa2,0xc4,0xd2,0x76,0x2f,0x81,0x7b,0x78,0x95,0xc5,0xbc,0x88,0xa0,0x45 }, /* 95, 0x527a792b183c7f64a0e8b1f4 */
{  }, /* 96, 0x */
{  }, /* 97, 0x */
{  }, /* 98, 0x */
{  }, /* 99, 0x */
{ 0x03,0xd2,0x06,0x3d,0x40,0x40,0x2f,0x03,0x0d,0x4c,0xc7,0x13,0x31,0x46,0x88,0x27,0xaa,0x41,0xa8,0xa0,0x9b,0xd6,0xfd,0x80,0x1b,0xa7,0x7f,0xb6,0x4f,0x8e,0x67,0xe6,0x17 }, /*100, 0x0af55fc59c335c8ec67ed24826 */
{  }, /*101, 0x */
{  }, /*102, 0x */
{  }, /*103, 0x */
{  }, /*104, 0x */
{ 0x03,0xbc,0xf7,0xce,0x88,0x7f,0xfc,0xa5,0xe6,0x2c,0x9c,0xab,0xbd,0xb7,0xff,0xa7,0x1d,0xc1,0x83,0xc5,0x2c,0x04,0xff,0x4e,0xe5,0xee,0x82,0xe0,0xc5,0x5c,0x39,0xd7,0x7b }, /*105, 0x */
{  }, /*106, 0x */
{  }, /*107, 0x */
{  }, /*108, 0x */
{  }, /*109, 0x */
{ 0x03,0x09,0x97,0x6b,0xa5,0x57,0x09,0x66,0xbf,0x88,0x91,0x96,0xb7,0xfd,0xf5,0xa0,0xf9,0xa1,0xe9,0xab,0x34,0x05,0x56,0xec,0x29,0xf8,0xbb,0x60,0x59,0x96,0x16,0x16,0x7d }, /*110, 0x */
{  }, /*111, 0x */
{  }, /*112, 0x */
{  }, /*113, 0x */
{  }, /*114, 0x */
{ 0x02,0x48,0xd3,0x13,0xb0,0x39,0x8d,0x49,0x23,0xcd,0xca,0x73,0xb8,0xcf,0xa6,0x53,0x2b,0x91,0xb9,0x67,0x03,0x90,0x2f,0xc8,0xb3,0x2f,0xd4,0x38,0xa3,0xb7,0xcd,0x7f,0x55 }, /*115, 0x */
{  }, /*116, 0x */
{  }, /*117, 0x */
{  }, /*118, 0x */
{  }, /*119, 0x */
{ 0x02,0xce,0xb6,0xcb,0xbc,0xdb,0xdf,0x5e,0xf7,0x15,0x06,0x82,0x15,0x0f,0x4c,0xe2,0xc6,0xf4,0x80,0x7b,0x34,0x98,0x27,0xdc,0xdb,0xdd,0x1f,0x2e,0xfa,0x88,0x5a,0x26,0x30 }, /*120, 0x */
{  }, /*121, 0x */
{  }, /*122, 0x */
{  }, /*123, 0x */
{  }, /*124, 0x */
{ 0x02,0x33,0x70,0x9e,0xb1,0x1e,0x0d,0x44,0x39,0xa7,0x29,0xf2,0x1c,0x2c,0x44,0x3d,0xed,0xb7,0x27,0x52,0x82,0x29,0x71,0x3f,0x00,0x65,0x72,0x1b,0xa8,0xfa,0x46,0xf0,0x0e }, /*125, 0x */
{  }, /*126, 0x */
{  }, /*127, 0x */
{  }, /*128, 0x */
{  }, /*129, 0x */
{ 0x03,0x63,0x3c,0xbe,0x3e,0xc0,0x2b,0x94,0x01,0xc5,0xef,0xfa,0x14,0x4c,0x5b,0x4d,0x22,0xf8,0x79,0x40,0x25,0x96,0x34,0x85,0x8f,0xc7,0xe5,0x9b,0x1c,0x09,0x93,0x78,0x52 }, /*130, 0x */
{  }, /*131, 0x */
{  }, /*132, 0x */
{  }, /*133, 0x */
{  }, /*134, 0x */
{ 0x02,0x14,0x5d,0x26,0x11,0xc8,0x23,0xa3,0x96,0xef,0x67,0x12,0xce,0x0f,0x71,0x2f,0x09,0xb9,0xb4,0xf3,0x13,0x5e,0x3e,0x0a,0xa3,0x23,0x0f,0xb9,0xb6,0xd0,0x8d,0x1e,0x16 }, /*135, 0x */
{  }, /*136, 0x */
{  }, /*137, 0x */
{  }, /*138, 0x */
{  }, /*139, 0x */
{ 0x03,0x1f,0x6a,0x33,0x2d,0x3c,0x5c,0x4f,0x2d,0xe2,0x37,0x8c,0x01,0x2f,0x42,0x9c,0xd1,0x09,0xba,0x07,0xd6,0x96,0x90,0xc6,0xc7,0x01,0xb6,0xbb,0x87,0x86,0x0d,0x66,0x40 }, /*140, 0x */
{  }, /*141, 0x */
{  }, /*142, 0x */
{  }, /*143, 0x */
{  }, /*144, 0x */
{ 0x03,0xaf,0xdd,0xa4,0x97,0x36,0x9e,0x21,0x9a,0x2c,0x1c,0x36,0x99,0x54,0xa9,0x30,0xe4,0xd3,0x74,0x09,0x68,0xe5,0xe4,0x35,0x24,0x75,0xbc,0xff,0xce,0x31,0x40,0xda,0xe5 }, /*145, 0x */
{  }, /*146, 0x */
{  }, /*147, 0x */
{  }, /*148, 0x */
{  }, /*149, 0x */
{ 0x03,0x13,0x78,0x07,0x79,0x0e,0xa7,0xdc,0x6e,0x97,0x90,0x1c,0x2b,0xc8,0x74,0x11,0xf4,0x5e,0xd7,0x4a,0x56,0x29,0x31,0x5c,0x4e,0x4b,0x03,0xa0,0xa1,0x02,0x25,0x0c,0x49 }, /*150, 0x */
{  }, /*151, 0x */
{  }, /*152, 0x */
{  }, /*153, 0x */
{  }, /*154, 0x */
{ 0x03,0x5c,0xd1,0x85,0x4c,0xae,0x45,0x39,0x1c,0xa4,0xec,0x42,0x8c,0xc7,0xe6,0xc7,0xd9,0x98,0x44,0x24,0xb9,0x54,0x20,0x9a,0x8e,0xea,0x19,0x7b,0x9e,0x36,0x4c,0x05,0xf6 }, /*155, 0x */
{  }, /*156, 0x */
{  }, /*157, 0x */
{  }, /*158, 0x */
{  }, /*159, 0x */
{ 0x02,0xe0,0xa8,0xb0,0x39,0x28,0x2f,0xaf,0x6f,0xe0,0xfd,0x76,0x9c,0xfb,0xc4,0xb6,0xb4,0xcf,0x87,0x58,0xba,0x68,0x22,0x0e,0xac,0x42,0x0e,0x32,0xb9,0x1d,0xdf,0xa6,0x73 }, /*160, 0x */

{  },{  },{  },{  },{  },{  },{  },{  },{  },{  }
};


/////////////////////////////////////////////////
// support functions

// time format
void passtime_old(char *s, size_t max, const struct tm *tm){
	snprintf(s, max, "%01iy %01im %01id %02i:%02i:%02is", tm->tm_year-70, tm->tm_mon, tm->tm_mday-1, tm->tm_hour, tm->tm_min, tm->tm_sec);
}

void passtime(char *s, size_t max, const struct tm *tm){
	size_t offset_start = 0;
	if( tm->tm_year-70 > 0	){ 
		snprintf(&s[offset_start], max-offset_start, " %1iy", tm->tm_year-70 ); 
		offset_start += 3 ; 
		if (((tm->tm_year-70)/10)!=0) offset_start += 1 ; 
		if (((tm->tm_year-70)/100)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/1000)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/10000)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/100000)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/1000000)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/10000000)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/100000000)!=0) offset_start += 1 ;
		if (((tm->tm_year-70)/1000000000)!=0) offset_start += 1 ;
	}
	if( tm->tm_mon > 0 || tm->tm_year-70 > 0 ){ 
		snprintf(&s[offset_start], max-offset_start, " %2im", tm->tm_mon	); 
		offset_start += 4 ; 
	}
	if( tm->tm_mday-1 > 0 || tm->tm_mon > 0 || tm->tm_year-70 > 0 ){ 
		snprintf(&s[offset_start], max-offset_start, " %2id", tm->tm_mday-1	); 
		offset_start += 4 ; 
	}
	snprintf(&s[offset_start], max-offset_start, " %02i:%02i:%02is", tm->tm_hour, tm->tm_min, tm->tm_sec);
}


// usage
void usage(int argc, char **argv){
	int bits = 40;
	printf("\n");
	printf("\n[usage] %s [bits] [pubkey]", argv[0]);
	printf("\n        %s %i", argv[0], bits);
	printf("\n        %s %i ", argv[0], bits); 
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X", default_pubkeys[bits][i]);}
	printf("\n");
	printf("\n[usage] %s [start:end] [pubkey]", argv[0]);
	printf("\n        %s 9ABCDEF123:F34567890A ", argv[0]); 
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X", default_pubkeys[bits][i]);}
	printf("\n");
	exit(EXIT_FAILURE);
}


// Kilo/Mega/Giga/Tera/Peta/Exa/Zetta/Yotta
unsigned char * prefSI(char *s, size_t max, double num){
	size_t prefSI_index = 0;
	char prefSI_list[9] = {' ', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'};
	while ( (uint64_t)(num/1000) > 0 ) { 
		prefSI_index += 1;
		num /= 1000;
	}
	snprintf(&s[0], max, "%5.1lf", num);
	snprintf(&s[0+5], max-5, "%c", prefSI_list[prefSI_index]); 
	return s;
}


double difftime_double(struct timeval * utimenow, struct timeval * utimelast){

	double timepass_double = utimenow->tv_sec - utimelast->tv_sec;
	if(utimenow->tv_usec >= utimelast->tv_usec){ 
		timepass_double += (double)(utimenow->tv_usec - utimelast->tv_usec)/1000000 ;
	}else{
		timepass_double -= 1;
		timepass_double += (double)(1000000 + utimenow->tv_usec - utimelast->tv_usec)/1000000 ;
	}
	return timepass_double;
}

/////////////////////////////////////////////////
// main

int main(int argc, char **argv) {

	setbuf(stdout, NULL); // cancel channel buffering (for printf)

	/////////////////////////////////////////////////
	// init

	//secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);
	secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);

	//ecmult vars
	secp256k1_scalar scalar_K; secp256k1_scalar_set_int(&scalar_K, 123456);
	secp256k1_scalar scalar_0; secp256k1_scalar_set_int(&scalar_0, 0);
	secp256k1_gej point_0gej; secp256k1_gej_set_infinity(&point_0gej);
	//Double multiply: R = na*A + ng*G
	//secp256k1_ecmult(&ctx->ecmult_ctx, &gej, &secp256k1_gej_const_g,	&scalar_K, &scalar_0); //1x
	//secp256k1_ecmult(&ctx->ecmult_ctx, &gej, NULL,			&scalar_0, &scalar_K); //2x
	//secp256k1_ecmult(&ctx->ecmult_ctx, &gej, &point_0gej,			&scalar_0, &scalar_K); //2x

	//for secp256k1_gej_add_var
	secp256k1_gej secp256k1_gej_const_g;
	secp256k1_gej_set_ge(&secp256k1_gej_const_g, &secp256k1_ge_const_g);

	// 1
	secp256k1_scalar scalar_1;
	secp256k1_scalar_set_int(&scalar_1, (unsigned int) 1);

	// fe tmp
	secp256k1_fe FE;

	// storage tmp
	secp256k1_fe_storage ST;

	/////////////////////////////////////////////////
	// buffers

	unsigned char buff_b32[32+1] = {0};
	memset(buff_b32, 0, sizeof(buff_b32) );

	unsigned char new_pubkey[65+1] = {0};
	unsigned char raw_pubkey[65+1] = {0};

	/////////////////////////////////////////////////
	// time

	time_t timetotal, timelast, timenow, timepass;
	timetotal = timelast = timenow = time(NULL);
	struct tm *timetm;
	char timebuff[255+1] = {0};

	struct timeval utimetotal, utimelast, utimenow;
	gettimeofday(&utimetotal, NULL);
	gettimeofday(&utimelast, NULL);
	gettimeofday(&utimenow, NULL);

	double timepass_double;

	/////////////////////////////////////////////////
	// logo

	printf("\n[###########################################################]");
	printf("\n[#          Pollard-kangaroo PrivKey Recovery Tool         #]");
	printf("\n[#            C99, bitcoin-core/secp256k1 library          #]");
	printf("\n[#                        singlecore                       #]");
	//printf("\n[#                         multicore                       #]");
	printf("\n[#                          ver%4s                        #]", version);
	printf("\n[###########################################################]");
	timenow = time(NULL);
	strftime(timebuff, sizeof(timebuff), "%d %b %Y %H:%M:%S", gmtime(&timenow));
	//strftime(timebuff, sizeof(timebuff), "%X", gmtime(&timenow));
	printf("\n[DATE(utc)] %s", timebuff);
	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");

	/////////////////////////////////////////////////
	// L, U, W, Wsqrt, MidW

	int pow2L, pow2U, pow2W;
	secp256k1_scalar scalar_L, scalar_U, scalar_W;

	if (argc >= 2) {
		char buff_L[64+1]={0}, buff_U[64+1]={0}, buff_02X[99]={0};
		//printf("\n[argv1] ");for(int i=0; i<strlen(argv[1]) ; ++i){printf("%c", argv[1][i]);};exit(1);
		if( 
			(argc >= 3 && (strlen(argv[2])==2*33 || strlen(argv[2])==2*65))
			&& sscanf(argv[1], "%64[^:]:%64[^:]", buff_L, buff_U) == 2 
		){

			printf("\n[i] custom range loaded from argv1");

			// L
			memset(buff_b32, 0, sizeof(buff_b32) );
			if(!(strlen(buff_L)%2)){
				for(int i=0; i<32 ; ++i){sscanf(&buff_L[2*i],"%02X",&buff_b32[i+((64-strlen(buff_L))/2)]);}
			}else{
				memset(buff_02X, 0, sizeof(buff_02X) );
				buff_02X[0] = 48; // zero in ascii
				strcat(buff_02X, buff_L);
				for(int i=0; i<32 ; ++i){sscanf(&buff_02X[2*i],"%02X",&buff_b32[i+((64-strlen(buff_02X))/2)]);}
			}
			secp256k1_scalar_set_b32(&scalar_L, buff_b32, NULL);

			// pow2L
			scalar_K = scalar_L;
			for(int i = 0 ; i < 256; ++i ){
				secp256k1_scalar_mul_shift_var(&scalar_K, &scalar_K, &scalar_1, (unsigned int) 1 );
				secp256k1_scalar_get_b32(buff_b32, &scalar_K);
				pow2L = i+0;
				if (secp256k1_scalar_is_one(&scalar_K)) break;
			}
			secp256k1_scalar_get_b32(buff_b32, &scalar_L);
			printf("\n[L] (~2^%i) 0x", pow2L);for(int i=0; i<32 ; ++i){printf("%02X", buff_b32[i]);}

			// U
			memset(buff_b32, 0, sizeof(buff_b32) );
			if(!(strlen(buff_U)%2)){
				for(int i=0; i<32 ; ++i){sscanf(&buff_U[2*i],"%02X",&buff_b32[i+((64-strlen(buff_U))/2)]);}
			}else{
				memset(buff_02X, 0, sizeof(buff_02X) );
				buff_02X[0] = 48; // zero in ascii
				strcat(buff_02X, buff_U);
				for(int i=0; i<32 ; ++i){sscanf(&buff_02X[2*i],"%02X",&buff_b32[i+((64-strlen(buff_02X))/2)]);}
			}
			secp256k1_scalar_set_b32(&scalar_U, buff_b32, NULL);

			// pow2U
			//scalar_K = scalar_U;
			//for(int i = 0 ; i < 256; ++i ){
			//	secp256k1_scalar_mul_shift_var(&scalar_K, &scalar_K, &scalar_1, (unsigned int) 1 );
			//	secp256k1_scalar_get_b32(buff_b32, &scalar_K);
			//	pow2U = i+1;
			//	if (secp256k1_scalar_is_one(&scalar_K)) break;
			//}
			pow2U = pow2L+1;
			secp256k1_scalar_get_b32(buff_b32, &scalar_U);
			printf("\n[U] (~2^%i) 0x", pow2U);for(int i=0; i<32 ; ++i){printf("%02X", buff_b32[i]);}

			// W = U - L
			secp256k1_scalar_negate(&scalar_K, &scalar_L);
			secp256k1_scalar_add(&scalar_W, &scalar_U, &scalar_K);

			// pow2W
			scalar_K = scalar_W;
			for(int i = 0 ; i < 256; ++i ){
				secp256k1_scalar_mul_shift_var(&scalar_K, &scalar_K, &scalar_1, (unsigned int) 1 );
				secp256k1_scalar_get_b32(buff_b32, &scalar_K);
				pow2W = i+1;
				if (secp256k1_scalar_is_one(&scalar_K)) break;
			}
			secp256k1_scalar_get_b32(buff_b32, &scalar_W);
			printf("\n[W] (~2^%i) 0x", pow2W);for(int i=0; i<32 ; ++i){printf("%02X", buff_b32[i]);}

			pow2bits = pow2U;
			
		}else{
			pow2bits = atoi(argv[1]);

			// W = [L..U]
			pow2L	= pow2bits-1 ; 
			pow2U	= pow2bits-0 ; 
			pow2W	= pow2bits-1 ; 

			secp256k1_scalar_cadd_bit(&scalar_L, (unsigned int) pow2L, 1);
			secp256k1_scalar_cadd_bit(&scalar_U, (unsigned int) pow2U, 1);
			secp256k1_scalar_cadd_bit(&scalar_W, (unsigned int) pow2W, 1);
		}

	}else{

		// W = [L..U]
		pow2L	= pow2bits-1 ; 
		pow2U	= pow2bits-0 ; 
		pow2W	= pow2bits-1 ; 

		secp256k1_scalar_cadd_bit(&scalar_L, (unsigned int) pow2L, 1);
		secp256k1_scalar_cadd_bit(&scalar_U, (unsigned int) pow2U, 1);
		secp256k1_scalar_cadd_bit(&scalar_W, (unsigned int) pow2W, 1);
	}


	//printf("\n[pow2W]		2^%u", pow2W);

	//bitMin,bitMax
	if ( pow2W < 8 || pow2W > 130) {
		printf("\n[error] bits must be 2^8..2^130!");
		usage(argc, argv);
	}
	if (pow2W > 70) {
		printf("\n[warning!] bits = 2^%i too big! long runtime expected", pow2bits);
	}
	

	// Wsqrt
	//int pow2Wsqrt	= (pow2W/2)+1 ; // 1<<(pow2bits-1)
	int pow2Wsqrt	= round((float)pow2W/2);
	secp256k1_scalar scalar_Wsqrt;
	secp256k1_scalar_cadd_bit(&scalar_Wsqrt, (unsigned int) pow2Wsqrt, 1);
	//uint128_t Wsqrt128 = (uint128_t)1<<pow2Wsqrt

	// M = (L+U)/2 == L+(W/2)
	secp256k1_scalar scalar_M;
	secp256k1_scalar_add(&scalar_M, &scalar_L, &scalar_U);
	secp256k1_scalar_mul_shift_var(&scalar_M, &scalar_M, &scalar_1, (unsigned int) 1); // M = (1*W)/(2^1)


	/////////////////////////////////////////////////
	// discriminator of distinguished points

	unsigned int pow2dp = ((pow2W/2)-2);
	//pow2dp = 63;

	uint64_t DPmodule = (uint64_t)1<<pow2dp;
	//printf("\n[DPmodule] 0x%016lX ", DPmodule);
	//uint128_t DPmodule = (uint128_t) 1 << (uint128_t) pow2dp ;
	//printf("\n[DPmodule] 0x%016lX%016lX ", (uint64_t)(DPmodule>>64), (uint64_t)DPmodule );

	/////////////////////////////////////////////////
	// optimal max jumpsize

	unsigned int pow2Jmax = 0;
	unsigned int pre_compute_pow2Jmax[256] = 
{ 
   1,  1,  1,  1,  1,  1,  4,  4,  5,  6
,  7,  7,  8,  8,  9, 10, 10, 11, 11, 12
, 12, 13, 14, 14, 15, 15, 16, 16, 17, 18
, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23
, 23, 24, 24, 25, 26, 26, 27, 27, 28, 28
, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33
, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39
, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44
, 44, 45, 45, 46, 46, 47, 47, 48, 48, 49
, 50, 50, 51, 51, 52, 52, 53, 53, 54, 54
, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59
, 60, 60, 61, 61, 62, 62, 63, 63, 64, 64
, 65, 65, 66, 66, 67, 67, 68, 69, 69, 70
, 70, 71, 71, 72, 72, 73, 73, 74, 74, 75
, 75, 76, 76, 77, 77, 78, 78, 79, 79, 80
, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85
, 85, 86, 86, 87, 87, 88, 88, 89, 89, 90
, 90, 91, 91, 92, 92, 93, 93, 94, 94, 95
, 95, 96, 97, 97, 98, 98, 99, 99,100,100
,101,101,102,102,103,103,104,104,105,105
,106,106,107,107,108,108,109,109,110,110
,111,111,112,112,113,113,114,114,115,115
,116,116,117,117,118,118,119,119,120,120
,121,121,122,122,123,123,124,124,125,125
,126,126,127,127,128,128,129,129,130,130
,131,131,132,132,133,133
};

	pow2Jmax = pre_compute_pow2Jmax[pow2W];
	//printf("\n[pow2Jmax] %u ", pow2Jmax);

	/////////////////////////////////////////////////
	// print settings

	//printf("\n[pow2bits]	2^%u", pow2bits);

	printf("\n[rangeW]	2^%u..2^%u ; W = U - L = 2^%u"
		, pow2L, pow2U
		, pow2W
	);

	printf("\n[jumpsize]	2^%u max", pow2Jmax);

	printf("\n[DPsize]	%u (hashtable size)", maxDP);
	//printf("\n[DPmodule]	0x%016lX ", DPmodule);

	#if	ALGO_CALC == 0 
	printf("\n[algo#0]	A + A -> A,  xA ready ; the fastest");
	#elif	ALGO_CALC == 1 
	printf("\n[algo#1]	J + A -> J,  xJ->xA   ; secp256k1_gej_add_ge_var()");
	#elif	ALGO_CALC == 2 
	printf("\n[algo#2]	J + A -> J,  xJ->xA   ; secp256k1_gej_add_ge()");
	#elif	ALGO_CALC == 3 
	printf("\n[algo#3]	0*P0+k*G->J, xJ->xA   ; secp256k1_ecmult()");
	#elif	ALGO_CALC == 4 
	printf("\n[algo#4]	k*G->J, J+J->J, xJ->xA; secp256k1_ecmult_gen()");
	#endif


	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");

	/////////////////////////////////////////////////
	// load pubkey


	if (argc >= 3 && (strlen(argv[2])==2*33 || strlen(argv[2])==2*65)) {
		printf("\n --> CUSTOM MODE");
		if (strlen(argv[2])==2*33) LEN_PUBK = 33;
		if (strlen(argv[2])==2*65) LEN_PUBK = 65;
		printf("\n[i] custom pubkey#%i loaded from argv2 ", pow2bits);
		for(int i=0; i<LEN_PUBK ; ++i){sscanf(&argv[2][2*i],"%02X",&new_pubkey[i]);}
		printf("\n[pubkey#%i] ", pow2bits);
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",new_pubkey[i]);}
		memcpy(raw_pubkey, new_pubkey, LEN_PUBK );
		if ( LEN_PUBK == 33 ) printf("\n[i] compressed");
		if ( LEN_PUBK == 65 ) printf("\n[i] uncompressed");
/*
	}else if(0) {
		printf("\n --> CUSTOM MODE");
		LEN_PUBK = 33;
		//LEN_PUBK = 65;
		printf("\n ==> Enter pubkey: ");
		for(int i=0; i<LEN_PUBK ; ++i){scanf("%02X",&new_pubkey[i]);}
		printf("\n[i] custom pubkey#%i loaded from input \n[pubkey#%i] ", pow2bits, pow2bits
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",new_pubkey[i]);}
		memcpy(raw_pubkey, new_pubkey, LEN_PUBK );
*/
/*
	}else{
		printf("\n --> DEFAULT MODE");
		LEN_PUBK = 33;
		printf("\n[i] pubkey#%i loaded from default table ", pow2bits);
		printf("\n[pubkey#%i] ", pow2bits);
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",default_pubkeys[pow2bits][i]);}
		//strcpy(raw_pubkey, default_pubkeys[pow2bits]);
		//strncpy(raw_pubkey, default_pubkeys[pow2bits], sizeof(raw_pubkey));
		//strncpy(raw_pubkey, default_pubkeys[pow2bits], strlen(default_pubkeys[pow2bits]));
		memcpy(raw_pubkey, default_pubkeys[pow2bits], LEN_PUBK );
	}
*/

	}else{
		printf("\n --> RANDOM MODE");

		LEN_PUBK = 33;

		secp256k1_scalar scalar_prvkey_origin;

		// gen new random prvkey 0..2^256
		if(0){
			// not work! wtf?..
			//secp256k1_rand256(buff_b32); 
		}else{
			// ok, alternative
			gettimeofday(&utimenow, NULL);
			if (!strlen(seed16)) 
				for(int i = 0 ; i < 16; ++i)
					{ seed16[i] = (unsigned char) ((uint64_t)((uint64_t)utimenow.tv_sec*utimenow.tv_usec)>>i); }
			secp256k1_rfc6979_hmac_sha256 secp256k1_test_rng;
			secp256k1_rfc6979_hmac_sha256_initialize(&secp256k1_test_rng, seed16, 16);
			secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, buff_b32, 32);
		}
		secp256k1_scalar_set_b32(&scalar_prvkey_origin, buff_b32, NULL);

		//printf("\n[PRNGseed] 0x");for(int i=0; i<16 ; ++i){printf("%02X", seed16[i]);};exit(1);

		printf("\n[i] pubkey#%i randomly generated in range [2^%i..2^%i]", pow2bits, pow2bits-1, pow2bits);

		// stupid, but it work
		for(int i = 255 ; i > 0; --i ){
			secp256k1_scalar_mul_shift_var(&scalar_prvkey_origin, &scalar_prvkey_origin, &scalar_1, (unsigned int) 1 );
			secp256k1_scalar_get_b32(buff_b32, &scalar_prvkey_origin);
			secp256k1_fe_set_b32(&FE, buff_b32);
			secp256k1_fe FE_U;
			secp256k1_scalar_get_b32(buff_b32, &scalar_U);
			secp256k1_fe_set_b32(&FE_U, buff_b32);
			if ( secp256k1_fe_cmp_var(&FE, &FE_U) < 0 ) break;
		}

		secp256k1_scalar_get_b32(buff_b32, &scalar_prvkey_origin);
		printf("\n[prvkey#%i] 0x", pow2bits);
		for(int i=0; i<32 ; ++i){printf("%02X", buff_b32[i]);}

		secp256k1_pubkey pubkey_origin;
		if ( !secp256k1_ec_pubkey_create(ctx, &pubkey_origin, buff_b32) ) {
			printf("\n[FATAL_ERROR] can't create pubkey from prvkey!\n");
			exit(EXIT_FAILURE);
		}
			
		//memset(new_pubkey, 0, sizeof(new_pubkey));
		if ( !secp256k1_ec_pubkey_serialize(ctx, new_pubkey, &LEN_PUBK, &pubkey_origin, (LEN_PUBK==33 ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED) ) ) {
			printf("\n[FATAL_ERROR] pubkey invalid!\n");
			exit(EXIT_FAILURE);
		}

		printf("\n[pubkey#%i] ", pow2bits);
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",new_pubkey[i]);}
		memcpy(raw_pubkey, new_pubkey, LEN_PUBK );
	}

	
	//printf("\n[pubkey(final)] ");
	//for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",raw_pubkey[i]);};


	secp256k1_ge pointW0ge;
	// check
	if (!secp256k1_eckey_pubkey_parse(&pointW0ge, raw_pubkey, LEN_PUBK)) {
		printf("\n[error] Unparsable pubkey!");
		//printf("\n[FATAL ERROR]\n");
		//exit(EXIT_FAILURE);

		printf("\n --> DEFAULT MODE");
		LEN_PUBK = 33;
		printf("\n[i] pubkey#%i loaded from default table ", pow2bits);
		printf("\n[pubkey#%i] ", pow2bits);
		for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",default_pubkeys[pow2bits][i]);}
		memcpy(raw_pubkey, default_pubkeys[pow2bits], LEN_PUBK );
	}else{
		printf("\n --> pubkey valid!");
	}
	secp256k1_fe_normalize_var(&pointW0ge.x);
	secp256k1_fe_normalize_var(&pointW0ge.y);

	//printf("\n[pubkey(final)] ");
	//for(int i=0; i<LEN_PUBK ; ++i){printf("%02X",raw_pubkey[i]);};

	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");

	/////////////////////////////////////////////////
	// hashtable for distinguished points

	// DPht,DTht,DWht - points, distinguished points of Tp/Wp
	// in hashtable, provides uniqueness distinguished points

	uint64_t HASH_SIZE = 2* maxDP;

	typedef struct __attribute__((aligned(4))) hashtb_entry {
		uint64_t n0;
		//uint64_t n1;
		//uint64_t n2;
		//uint64_t n3;
		secp256k1_scalar distance;
	} hashtb_entry;

	#define ALLOC_ALIGN 1

	#if !ALLOC_ALIGN
	//hashtb_entry *DPht = (hashtb_entry *) malloc( HASH_SIZE * sizeof(struct hashtb_entry) );
	hashtb_entry *DPht = (hashtb_entry *) calloc( HASH_SIZE, sizeof(struct hashtb_entry) );
	#else
	hashtb_entry *DPht = (hashtb_entry *) aligned_alloc( 4, HASH_SIZE * sizeof(struct hashtb_entry) ); //C11
	#endif
	if( NULL == DPht ){ 
		printf("\n[memory] can't alloc mem %.2f %s", (float)(HASH_SIZE)*sizeof(struct hashtb_entry)/DIV_B/DIV_B/DIV_B, (DIV_B==1024?"GiB":"Gb") ); 
		printf("\n[FATAL ERROR]\n");exit(EXIT_FAILURE);
	}
	hashtb_entry *pDPht = DPht;

	/////////////////////////////////////////////////
	// pre-compute set S(i) jumps of pow2 jumpsize

	secp256k1_ge	SpGe[256];
	secp256k1_gej	SpGej[256];

	//1st point
	SpGe[0] = secp256k1_ge_const_g;
	secp256k1_gej_set_ge(&SpGej[0], &secp256k1_ge_const_g);

	//Nth points
	for(int i=1; i<256 ; ++i){
		secp256k1_gej_double_var(&SpGej[i], &SpGej[i-1], NULL);
		secp256k1_ge_set_gej(&SpGe[i], &SpGej[i]);
		//secp256k1_ge_set_gej_var(&SpGe[i], &SpGej[i]); // faster
	}
	//normalized?
	for(int i=0; i<256 ; ++i){
		secp256k1_fe_normalize_var(&SpGe[i].x);
		secp256k1_fe_normalize_var(&SpGe[i].y);
	}
	printf("\n[+] Sp-table of pow2 points - ready");

	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");

	/////////////////////////////////////////////////
	// 

	// Tp,Wp - point, sum of distance traveled
	secp256k1_ge	TpGe,	WpGe; 
	secp256k1_gej	TpGej,	WpGej; 

	// dT,dW - scalar, sum of distance traveled
	secp256k1_scalar scalar_dT, scalar_dW;

	// Tame
	//for(int i=0 ; i < HTmax ; ++i) {
	if (1) {
		scalar_dT = scalar_M;
		if(secp256k1_scalar_is_even(&scalar_dT)){ // +1, need check odd?
			secp256k1_scalar_add(&scalar_dT, &scalar_dT, &scalar_1);
		}
		secp256k1_ecmult(&ctx->ecmult_ctx, &TpGej, &point_0gej, &scalar_0, &scalar_dT); 
		secp256k1_ge_set_gej(&TpGe, &TpGej);
		//secp256k1_ge_set_gej_var(&TpGe, &TpGej); // faster
	}

	// Wild
	//for(int i=0 ; i < HWmax ; ++i) {
	if (1) {
		scalar_dW = scalar_1;
		secp256k1_ecmult(&ctx->ecmult_ctx, &WpGej, &point_0gej, &scalar_0, &scalar_dW); 
		secp256k1_gej_add_ge(&WpGej, &WpGej, &pointW0ge);
		//secp256k1_gej_add_ge_var(&WpGej, &WpGej, &pointW0ge, NULL);
		secp256k1_ge_set_gej(&WpGe, &WpGej);
		//secp256k1_ge_set_gej_var(&WpGe, &WpGej); // faster
	}

	//printf("\n[+] T%u+W%u herds - ready", HTmax, HWmax);
	printf("\n[+] T+W kangaroos - ready");

	//printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	// Affine points addition

// 2A -> A (1I, 2M, 2S)
void secp256k1_ge_double_var(secp256k1_ge *r, const secp256k1_ge *a){

	secp256k1_fe rX, rY;
	secp256k1_fe tmp1, tmp2;

	tmp1 = a->y;
	if ( (a->infinity == 1) || secp256k1_fe_normalizes_to_zero_var(&tmp1) ) { 
		secp256k1_ge_set_infinity(r);
		return;
	}

	// s = (3x^2 + A)/(2y)				# 1I 2M 1S
	// A=0 B=7 (secp256k1)
	secp256k1_fe_sqr(&tmp2, &a->x);//1S
	tmp1 = tmp2;
	secp256k1_fe_add(&tmp1, &tmp2);
	secp256k1_fe_add(&tmp1, &tmp2);
	secp256k1_fe_normalize_weak(&tmp1);

	tmp2 = a->y;
	secp256k1_fe_add(&tmp2, &a->y);
	secp256k1_fe_normalize_weak(&tmp2);
	secp256k1_fe_inv_var(&tmp2, &tmp2);//1I

	secp256k1_fe_mul(&tmp1, &tmp1, &tmp2);//1M

	// x' = s^2-2x					# 1S
	secp256k1_fe_sqr(&rX, &tmp1);//1S
	tmp2 = a->x;
	secp256k1_fe_add(&tmp2, &a->x);
	secp256k1_fe_negate(&tmp2, &tmp2, 1);
	secp256k1_fe_add(&rX, &tmp2);
	secp256k1_fe_normalize_weak(&rX);

	// y' = s(x-x')-y				# 1M
	secp256k1_fe_negate(&tmp2, &rX, 1);
	rY = a->x;
	secp256k1_fe_add(&rY, &tmp2);
	secp256k1_fe_normalize_weak(&rY);
	secp256k1_fe_mul(&rY, &rY, &tmp1);//1M
	secp256k1_fe_negate(&tmp2, &a->y, 1);
	secp256k1_fe_add(&rY, &tmp2);
	secp256k1_fe_normalize_weak(&rY);

	r->x = rX;
	r->y = rY;
}


// A + A -> A (1I, 2M, 1S)
void secp256k1_ge_add_ge_var(secp256k1_ge *r, const secp256k1_ge *a, const secp256k1_ge *b){
	

	if ( (a->infinity == 1) || (b->infinity == 1) ) { 
		if ( (a->infinity == 1) ^  (b->infinity == 1) ) {
			if (a->infinity == 1) { r->x = b->x; r->y = b->y; return; }
			if (b->infinity == 1) { r->x = a->x; r->y = a->y; return; }
		}else{
			secp256k1_ge_set_infinity(r);
			return;
		}
	}

	secp256k1_fe rX, rY;
	secp256k1_fe tmp1, tmp2;

	secp256k1_fe aXneg;
	secp256k1_fe_negate(&aXneg, &a->x, 1);
	secp256k1_fe aYneg;
	secp256k1_fe_negate(&aYneg, &a->y, 1);

	//dx = B.x - A.x
	tmp1 = b->x;
	secp256k1_fe_add(&tmp1, &aXneg);

	//dy = B.y - A.y
	tmp2 = b->y;
	secp256k1_fe_add(&tmp2, &aYneg);


	if (secp256k1_fe_normalizes_to_zero_var(&tmp1)) {
		if (secp256k1_fe_normalizes_to_zero_var(&tmp2)) {
			secp256k1_ge_double_var(r, a);
			return;
		}else{
			secp256k1_ge_set_infinity(r);
			return;
		}
	}

	secp256k1_fe_normalize_weak(&tmp1);
	secp256k1_fe_normalize_weak(&tmp2);

	secp256k1_fe_inv_var(&tmp1, &tmp1);//1I

	//c = dy * invert(dx, p) % p			# 1I,1M
	secp256k1_fe c;
	secp256k1_fe_mul(&tmp2, &tmp2, &tmp1);//1M

	//R.x = (c**2 - A.x - B.x) % p			# 1S
	secp256k1_fe_sqr(&rX, &tmp2);//1S
	secp256k1_fe_add(&rX, &aXneg);
	secp256k1_fe_negate(&tmp1, &b->x, 1);
	secp256k1_fe_add(&rX, &tmp1);
	secp256k1_fe_normalize_weak(&rX);

	//R.y = (c*(A.x - R.x) - A.y) % p		# 1M
	rY = a->x;
	secp256k1_fe_negate(&tmp1, &rX, 1);
	secp256k1_fe_add(&rY, &tmp1);
	secp256k1_fe_normalize_weak(&rY);
	secp256k1_fe_mul(&rY, &rY, &tmp2);//1M
	secp256k1_fe_add(&rY, &aYneg);
	secp256k1_fe_normalize_weak(&rY);

	r->x = rX;
	r->y = rY;
}


	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	// KANGAROOS
	
	printf("\n");

	//counts
	uint64_t n_jump = 0, n_lastjump = 0;
	uint64_t n_DT = 0, n_DW = 0;
	uint64_t n_coll = 0;

	unsigned int pow2rand;

	int flag_found = 0;

	secp256k1_scalar scalar_prvkey = scalar_0;
	secp256k1_scalar scalar_nowjumpsize = scalar_0;

	timelast = time(NULL);
	gettimeofday(&utimelast, NULL);

	// main loop
	while(1){
		
		// Tame herd
		//for(int i=0 ; i < HTmax ; ++i) {
		if(1){
			++n_jump;

			//secp256k1_fe_clear(FE);

			#if ALGO_CALC == 0
			// Affine is ready
			FE = TpGe.x;
			#else
			// Jacobian -> Affine
			secp256k1_fe Zinv;
			secp256k1_fe_inv_var(&Zinv, &TpGej.z);
			secp256k1_fe_sqr(&Zinv, &Zinv);
			secp256k1_fe_mul(&FE, &TpGej.x, &Zinv);
			#endif

			secp256k1_fe_normalize_var(&FE);

			secp256k1_fe_to_storage(&ST, &FE);

			// check, is it distinguished point?
			//if ( !(ST.n[0] % (uint64_t)DPmodule)  &&  !(ST.n[1] % (uint64_t)(DPmodule>>64)) ) {
			if (!(ST.n[0] % DPmodule)) {

			//if (!(FE.n[0] % DPmodule)) {
				//secp256k1_fe_to_storage(&ST, &FE);

				++n_DT;

				if (FLAG_DEBUG>0)	printf("\n[tame][DP T+W=%lu+%lu=%lu] new distinguished point!\n", n_DT, n_DW, n_DT+n_DW);

				if ( n_DT+n_DW >= maxDP ) { 
							printf("\n[FATAL_ERROR] DP hashtable overflow! T+W=%u+%u=%u (max:%u)\n", n_DT, n_DW, n_DT+n_DW, maxDP);
							exit(EXIT_FAILURE);
				}

        			uint64_t entry = ST.n[0] & (HASH_SIZE-1);
				while (DPht[entry].n0 != 0) {

					if (	   DPht[entry].n0 == ST.n[0]
						//&& DPht[entry].n1 == ST.n[1]
						//&& DPht[entry].n2 == ST.n[2]
						//&& DPht[entry].n3 == ST.n[3]
					) {
						secp256k1_fe fe_dT;
						secp256k1_scalar_get_b32(buff_b32, &scalar_dT);
						secp256k1_fe_set_b32(&fe_dT, buff_b32);
						secp256k1_fe fe_dW;
						secp256k1_scalar_get_b32(buff_b32, &DPht[entry].distance);
						secp256k1_fe_set_b32(&fe_dW, buff_b32);
						if (    -1 == secp256k1_fe_cmp_var(&fe_dT, &fe_dW) ) {
							secp256k1_scalar_negate(&scalar_K, &scalar_dT);
							secp256k1_scalar_add(&scalar_prvkey, &DPht[entry].distance, &scalar_K);
						}else if(1 == secp256k1_fe_cmp_var(&fe_dT, &fe_dW) ) {
							secp256k1_scalar_negate(&scalar_K, &DPht[entry].distance);
							secp256k1_scalar_add(&scalar_prvkey, &scalar_dT, &scalar_K);
						}else{
							printf("\n[FATAL_ERROR] dT == dW !!!\n");
							exit(EXIT_FAILURE);
						}

						flag_found = 1;

						//printf("\n[X] %016lx %016lx %016lx %016lx", ST.n[3], ST.n[2], ST.n[1], ST.n[0]);

						break;
					}
					++n_coll; // useless collision
					entry = (entry + (ST.n[1] | 1)) & (HASH_SIZE - 1);
				}
				if (flag_found) break;

				DPht[entry].distance = scalar_dT;
				DPht[entry].n0 = ST.n[0];
				//DPht[entry].n1 = ST.n[1];
				//DPht[entry].n2 = ST.n[2];
				//DPht[entry].n3 = ST.n[3];
			}
			
			if (flag_found) break;


			pow2rand = ST.n[0] % pow2Jmax ;
			//pow2rand = FE.n[0] % pow2Jmax ;

			//secp256k1_scalar_clear(&scalar_nowjumpsize);
			secp256k1_scalar_set_int(&scalar_nowjumpsize, 0);
			secp256k1_scalar_cadd_bit(&scalar_nowjumpsize, pow2rand, 1);

			//dT += nowjumpsize
			secp256k1_scalar_add(&scalar_dT, &scalar_dT, &scalar_nowjumpsize);


			//Tp[k] = PublicKey.combine_keys([Tp[k], Sp[pw]])
			#if ALGO_CALC == 0
			secp256k1_ge_add_ge_var(&TpGe, &TpGe, &SpGe[pow2rand]);
			
			#elif ALGO_CALC == 1
			secp256k1_gej_add_ge_var(&TpGej, &TpGej, &SpGe[pow2rand], NULL);

			#elif ALGO_CALC == 2
			secp256k1_gej_add_ge(&TpGej, &TpGej, &SpGe[pow2rand]);

			#elif ALGO_CALC == 3
			secp256k1_ecmult(&ctx->ecmult_ctx, &TpGej, &TpGej, &scalar_1, &scalar_nowjumpsize);

			#elif ALGO_CALC == 4
			secp256k1_gej tmpGej;
			secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &tmpGej, &scalar_nowjumpsize);
			secp256k1_gej_add_var(&TpGej, &TpGej, &tmpGej, NULL);
 			#endif 
		}

		if (flag_found) break;

		
		// Wild herd
		//for(int i=0 ; i < HWmax ; ++i) {
		if(1){
			++n_jump;

			//secp256k1_fe_clear(FE);

			#if ALGO_CALC == 0
			// Affine is ready
			FE = WpGe.x;
			#else
			// Jacobian -> Affine
			secp256k1_fe Zinv;
			secp256k1_fe_inv_var(&Zinv, &WpGej.z);
			secp256k1_fe_sqr(&Zinv, &Zinv);
			secp256k1_fe_mul(&FE, &WpGej.x, &Zinv);
			#endif

			secp256k1_fe_normalize_var(&FE);

			secp256k1_fe_to_storage(&ST, &FE);

			// check, is it distinguished point?
			//if ( !(ST.n[0] % (uint64_t)DPmodule)  &&  !(ST.n[1] % (uint64_t)(DPmodule>>64)) ) {
			if (!(ST.n[0] % DPmodule)) {

			//if (!(FE.n[0] % DPmodule)) {
				//secp256k1_fe_to_storage(&ST, &FE);

				++n_DW;

				if (FLAG_DEBUG>0)	printf("\n[wild][DP T+W=%lu+%lu=%lu] new distinguished point!\n", n_DT, n_DW, n_DT+n_DW);

				if ( n_DT+n_DW >= maxDP ) { 
							printf("\n[FATAL_ERROR] DP hashtable overflow! T+W=%u+%u=%u (max:%u)\n", n_DT, n_DW, n_DT+n_DW, maxDP);
							exit(EXIT_FAILURE);
				}

        			uint64_t entry = ST.n[0] & (HASH_SIZE-1);
				while (DPht[entry].n0 != 0) {

					if (	   DPht[entry].n0 == ST.n[0]
						//&& DPht[entry].n1 == ST.n[1]
						//&& DPht[entry].n2 == ST.n[2]
						//&& DPht[entry].n3 == ST.n[3]
					) {
						secp256k1_fe fe_dT;
						secp256k1_scalar_get_b32(buff_b32, &DPht[entry].distance);
						secp256k1_fe_set_b32(&fe_dT, buff_b32);
						secp256k1_fe fe_dW;
						secp256k1_scalar_get_b32(buff_b32, &scalar_dW);
						secp256k1_fe_set_b32(&fe_dW, buff_b32);
						if (    -1 == secp256k1_fe_cmp_var(&fe_dT, &fe_dW) ) {
							secp256k1_scalar_negate(&scalar_K, &DPht[entry].distance);
							secp256k1_scalar_add(&scalar_prvkey, &scalar_dW, &scalar_K);
						}else if(1 == secp256k1_fe_cmp_var(&fe_dT, &fe_dW) ) {
							secp256k1_scalar_negate(&scalar_K, &scalar_dW);
							secp256k1_scalar_add(&scalar_prvkey, &DPht[entry].distance, &scalar_K);
						}else{
							printf("\n[FATAL_ERROR] dT == dW !!!\n");
							exit(EXIT_FAILURE);
						}

						flag_found = 1;

						//printf("\n[X] %016lx %016lx %016lx %016lx", ST.n[3], ST.n[2], ST.n[1], ST.n[0]);

						break;
					}
					++n_coll; // useless collision
					entry = (entry + (ST.n[1] | 1)) & (HASH_SIZE - 1);
				}
				if (flag_found) break;

				DPht[entry].distance = scalar_dW;
				DPht[entry].n0 = ST.n[0];
				//DPht[entry].n1 = ST.n[1];
				//DPht[entry].n2 = ST.n[2];
				//DPht[entry].n3 = ST.n[3];
			}
			
			if (flag_found) break;


			pow2rand = ST.n[0] % pow2Jmax ;
			//pow2rand = FE.n[0] % pow2Jmax ;

			//secp256k1_scalar_clear(&scalar_nowjumpsize);
			secp256k1_scalar_set_int(&scalar_nowjumpsize, 0);
			secp256k1_scalar_cadd_bit(&scalar_nowjumpsize, pow2rand, 1);

			//dW += nowjumpsize
			secp256k1_scalar_add(&scalar_dW, &scalar_dW, &scalar_nowjumpsize);

			
			//Wp = PublicKey.combine_keys([Wp, Sp[pw]])
			#if ALGO_CALC == 0
			secp256k1_ge_add_ge_var(&WpGe, &WpGe, &SpGe[pow2rand]);

			#elif ALGO_CALC == 1
			secp256k1_gej_add_ge_var(&WpGej, &WpGej, &SpGe[pow2rand], NULL);

			#elif ALGO_CALC == 2
			secp256k1_gej_add_ge(&WpGej, &WpGej, &SpGe[pow2rand]);

			#elif ALGO_CALC == 3
			secp256k1_ecmult(&ctx->ecmult_ctx, &WpGej, &WpGej, &scalar_1, &scalar_nowjumpsize);

			#elif ALGO_CALC == 4
			secp256k1_gej tmpGej;
			secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &tmpGej, &scalar_nowjumpsize);
			secp256k1_gej_add_var(&WpGej, &WpGej, &tmpGej, NULL);
 			#endif
		}

		if (flag_found) break;

		// info, progress, time
		if (!(n_jump % 50000) || flag_found) {

			timenow = time(NULL);
			timepass = difftime(timenow,timelast);

			if(timepass >= 1) {

				//debug
				if (FLAG_DEBUG>0) printf("\r[i] DP T+W=%lu+%lu=%lu; dp/kgr=%.1lf; HashTableCollisions=%u                  \n"
					, n_DT,n_DW, n_DT+n_DW, (float)(n_DT+n_DW)/2, n_coll);


				timepass = difftime(timenow,timetotal);
				passtime(timebuff, sizeof(timebuff), gmtime(&timepass));
				//printf("\r --> [%s] ", timebuff);
				printf("\r [%s ;", timebuff);


				gettimeofday(&utimenow, NULL);
				timepass_double = difftime_double(&utimenow, &utimelast);

				double speed1sec = (double)(n_jump-n_lastjump)/timepass_double;
				//printf(" %.3fM j/s;", (float)speed1sec/1000000);
				printf(" %s j/s;", prefSI(buff_b32, sizeof(buff_b32), speed1sec) );


				if (pow2Wsqrt<62) {
					//printf(" %luj; DP T+W=%lu+%lu=%lu; dp/kgr=%.1f;", n_jump, n_DT, n_DW, n_DT+n_DW, (float)(n_DT+n_DW)/2 );
					printf(" %sj %4.1f%%; dp/kgr=%.1lf;"
						, prefSI(buff_b32, sizeof(buff_b32), n_jump)
						, (double)n_jump/(2*((uint64_t)1<<pow2Wsqrt))*100 
						, (float)(n_DT+n_DW)/2 
					);

					int64_t jumpleft = (2*((uint64_t)1<<pow2Wsqrt)) - n_jump;
					if (jumpleft > 0) {
						//timepass = jumpleft/(speed1sec+1); // div by zero?
						timepass = jumpleft/speed1sec;
						passtime(timebuff, sizeof(timebuff), gmtime(&timepass));
						printf("%s ]", timebuff);
					}else{
						timepass = 0;
						passtime(timebuff, sizeof(timebuff), gmtime(&timepass));
						printf("%s ]", timebuff);
					}
				}else{
					//printf(" %luj; DP T+W=%lu+%lu=%lu; dp/kgr=%.1f;", n_jump, n_DT, n_DW, n_DT+n_DW, (float)(n_DT+n_DW)/2 );
					printf(" %luj; dp/kgr=%.1lf;", n_jump, (float)(n_DT+n_DW)/2 );

					printf(" __infinity__ ]");
				}

				printf("   ");

				timelast = timenow;
				utimelast.tv_sec = utimenow.tv_sec;
				utimelast.tv_usec = utimenow.tv_usec;
				n_lastjump = n_jump;
			}

		}
	}

	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");


	//print prvkey
	secp256k1_scalar_get_b32(buff_b32, &scalar_prvkey);
	printf("\n[prvkey#%i] 0x", pow2bits);
	for(int i=0; i<32 ; ++i){printf("%02X", buff_b32[i]);}

	/////////////////////////////////////////////////
	//double-check

	if (1) {

			secp256k1_pubkey pubk_cand;
			if ( !secp256k1_ec_pubkey_create(ctx, &pubk_cand, buff_b32) ) {
				printf("\n[double-check] failed!");
				printf("\n[FATAL_ERROR] can't create pubkey from prvkey!\n");
				exit(EXIT_FAILURE);
			}
				
			memset(new_pubkey, 0, sizeof(new_pubkey));
			if ( !secp256k1_ec_pubkey_serialize(ctx, new_pubkey, &LEN_PUBK, &pubk_cand, (LEN_PUBK==33 ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED) ) ) {
				printf("\n[double-check] failed!");
				printf("\n[FATAL_ERROR] pubkey invalid!\n");
				exit(EXIT_FAILURE);
			}

			secp256k1_ge pubk_cand_ge;
			secp256k1_pubkey_load(ctx, &pubk_cand_ge, &pubk_cand);

			if(	0==secp256k1_fe_cmp_var(&pointW0ge.x, &pubk_cand_ge.x) 
				&&	
				0==secp256k1_fe_cmp_var(&pointW0ge.y, &pubk_cand_ge.y) 
			){
					//printf("\n[+] prvkey correct!" );

				if(1){ //save?

					FILE *f_save;
					char f_name[100] = "_found_prvkey.txt";
					//snprintf(f_name, sizeof(f_name), "_found_prvkey.txt" );

					char msg[1000];
					if( NULL != (f_save = fopen(f_name, "ab"))){ 
						for(int i=0; i<32; ++i){sprintf(&msg[i*2],"%02X",buff_b32[i]);};
						fwrite(&msg[0], 1 , 64, f_save);
						sprintf(&msg[0],"%s",":");
						fwrite(&msg[0], 1 , 1, f_save);
						for(int i=0; i<LEN_PUBK; ++i){sprintf(&msg[i*2],"%02X",new_pubkey[i]);};
						fwrite(&msg[0], 1 , LEN_PUBK*2, f_save);
						sprintf(&msg[0],"%s","\n");
						fwrite(&msg[0], 1 , 1, f_save);
						fclose(f_save);

						printf("\n[i] success saved pair prvkey:pubkey to file '%s'", f_name);
					}else{
						printf("\n[error] file '%s' not writable!", f_name);
					}

				}else{
					printf("\n[double-check] failed!");
					printf("\n[pubkey#%i] ", pow2bits);for(int i=0; i<LEN_PUBK; ++i){printf("%02X",new_pubkey[i]);};
					printf("\n[origin#%i] ", pow2bits);for(int i=0; i<LEN_PUBK; ++i){printf("%02X",raw_pubkey[i]);};
					printf("\n[FATAL_ERROR] pubkey invalid!\n");
					exit(EXIT_FAILURE);
				}
			}
	}

	/////////////////////////////////////////////////
	//print info

	gettimeofday(&utimenow, NULL);
	timepass_double = difftime_double(&utimenow, &utimetotal);

	if (pow2Wsqrt<62) {
		printf("\n[i]");
		printf(" %s j/s;"
			, ( timepass_double != 0 
				? prefSI(buff_b32, sizeof(buff_b32), n_jump/timepass_double) 
				: prefSI(buff_b32, sizeof(buff_b32), n_jump) 
			)
		);
		printf(" %sj", prefSI(buff_b32, sizeof(buff_b32), n_jump) );
		printf(" of %sj", prefSI(buff_b32, sizeof(buff_b32), 2*((uint64_t)1<<pow2Wsqrt) ) );
		printf(" %4.1f%%", (double)n_jump/(2*((uint64_t)1<<pow2Wsqrt))*100 );
		printf("; DP T+W=%lu+%lu=%lu; dp/kgr=%.1f;", n_DT, n_DW, n_DT+n_DW, (float)(n_DT+n_DW)/2 );
	}else{
		printf("\n[i]");
		printf(" %s j/s;"
			, ( timepass_double != 0 
				? prefSI(buff_b32, sizeof(buff_b32), n_jump/timepass_double) 
				: prefSI(buff_b32, sizeof(buff_b32), n_jump) 
			)
		);
		printf(" %sj", prefSI(buff_b32, sizeof(buff_b32), n_jump) );
		printf(" of 2*2^%ij", pow2Wsqrt );
		printf("; DP T+W=%lu+%lu=%lu; dp/kgr=%.1f;", n_DT, n_DW, n_DT+n_DW, (float)(n_DT+n_DW)/2 );

	}

	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////


if(1){
	timenow = time(NULL);
	timepass = difftime(timenow,timetotal);
	passtime(timebuff, sizeof(timebuff), gmtime(&timepass));
	printf("\n[#############################; passtime: %18s]", timebuff);
}
if(1){
	gettimeofday(&utimenow, NULL);
	if(utimenow.tv_usec >= utimetotal.tv_usec){ 
		printf("\n[####################################; precision: %3lis %3lims]", 
			utimenow.tv_sec-utimetotal.tv_sec,
			(utimenow.tv_usec-utimetotal.tv_usec)/1000 
		);
	}else{
		printf("\n[####################################; precision: %3lis %3lims]", 
			utimenow.tv_sec-utimetotal.tv_sec-1, 
			(1000000 + utimenow.tv_usec-utimetotal.tv_usec)/1000 
		);
	}
}

	/////////////////////////////////////////////////

	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");
	timenow = time(NULL);
	strftime(timebuff, sizeof(timebuff), "%d %b %Y %H:%M:%S", gmtime(&timenow));
	//strftime(timebuff, sizeof(timebuff), "%X", gmtime(&timenow));
	printf("\n[DATE(utc)] %s", timebuff);
	printf("\n[~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]");

	/////////////////////////////////////////////////

printf("\n[x] EXIT\n");exit(EXIT_SUCCESS);
}
/////////////////////////////////////////////////
/////////////////////////////////////////////////


